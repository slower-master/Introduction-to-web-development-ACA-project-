"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.deleteFunction = exports.updateFunction = exports.listAllFunctions = exports.listFunctions = exports.getFunction = exports.createFunction = exports.generateUploadUrl = exports.PUBSUB_PUBLISH_EVENT = void 0;
const clc = require("cli-color");
const apiv2_1 = require("../apiv2");
const error_1 = require("../error");
const api_1 = require("../api");
const logger_1 = require("../logger");
const proto = require("./proto");
const utils = require("../utils");
const API_VERSION = "v2alpha";
const client = new apiv2_1.Client({
    urlPrefix: api_1.functionsV2Origin,
    auth: true,
    apiVersion: "v2alpha",
});
exports.PUBSUB_PUBLISH_EVENT = "google.cloud.pubsub.topic.v1.messagePublished";
function functionsOpLogReject(funcName, type, err) {
    var _a, _b;
    if (((_b = (_a = err === null || err === void 0 ? void 0 : err.context) === null || _a === void 0 ? void 0 : _a.response) === null || _b === void 0 ? void 0 : _b.statusCode) === 429) {
        utils.logWarning(`${clc.bold.yellow("functions:")} got "Quota Exceeded" error while trying to ${type} ${funcName}. Waiting to retry...`);
    }
    else {
        utils.logWarning(clc.bold.yellow("functions:") + " failed to " + type + " function " + funcName);
    }
    throw new error_1.FirebaseError(`Failed to ${type} function ${funcName}`, {
        original: err,
        context: { function: funcName },
    });
}
async function generateUploadUrl(projectId, location) {
    try {
        const res = await client.post(`projects/${projectId}/locations/${location}:generateUploadUrl`);
        return res.body;
    }
    catch (err) {
        logger_1.logger.info("\n\nThere was an issue deploying your functions. Verify that your project has a Google App Engine instance setup at https://console.cloud.google.com/appengine and try again. If this issue persists, please contact support.");
        throw err;
    }
}
exports.generateUploadUrl = generateUploadUrl;
async function createFunction(cloudFunction) {
    const path = cloudFunction.name.substring(0, cloudFunction.name.lastIndexOf("/"));
    try {
        const res = await client.post(path, cloudFunction);
        return res.body;
    }
    catch (err) {
        throw functionsOpLogReject(cloudFunction.name, "create", err);
    }
}
exports.createFunction = createFunction;
async function getFunction(projectId, location, functionId) {
    const name = `projects/${projectId}/locations/${location}/functions/${functionId}`;
    const res = await client.get(name);
    return res.body;
}
exports.getFunction = getFunction;
async function listFunctions(projectId, region) {
    const res = await listFunctionsInternal(projectId, region);
    if (res.unreachable.includes(region)) {
        throw new error_1.FirebaseError(`Cloud Functions region ${region} is unavailable`);
    }
    return res.functions;
}
exports.listFunctions = listFunctions;
async function listAllFunctions(projectId) {
    return await listFunctionsInternal(projectId, "-");
}
exports.listAllFunctions = listAllFunctions;
async function listFunctionsInternal(projectId, region) {
    const functions = [];
    const unreacahble = new Set();
    let pageToken = "";
    while (true) {
        const res = await client.get(`projects/${projectId}/locations/us-central1/functions`, { queryParams: { pageToken } });
        functions.push(...(res.body.functions || []));
        for (const region of res.body.unreachable || []) {
            unreacahble.add(region);
        }
        if (!res.body.nextPageToken) {
            return {
                functions,
                unreachable: Array.from(unreacahble),
            };
        }
        pageToken = res.body.nextPageToken;
    }
}
async function updateFunction(cloudFunction) {
    try {
        const queryParams = {
            updateMask: proto.fieldMasks(cloudFunction).join(","),
        };
        const res = await client.patch(cloudFunction.name, cloudFunction, { queryParams });
        return res.body;
    }
    catch (err) {
        throw functionsOpLogReject(cloudFunction.name, "update", err);
    }
}
exports.updateFunction = updateFunction;
async function deleteFunction(cloudFunction) {
    try {
        const res = await client.delete(cloudFunction.name);
        return res.body;
    }
    catch (err) {
        throw functionsOpLogReject(cloudFunction.name, "update", err);
    }
}
exports.deleteFunction = deleteFunction;
